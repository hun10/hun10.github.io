<!DOCTYPE html>
<html>
<head>

<title>
Д. Урбанович — Алгоритм Франка
</title>

</head>
<body>

<h1>
Алгоритм Франка
</h1>

<p>
<a href="/log">Дмитрий Урбанович</a>
</p>

<p>
Ижевск, 15—16 июня 2018
</p>

<p>
Обновлено 9 января 2021 (MathML)
</p>

<hr/>

<p>
Алгоритм Франка — это легкий по затратам памяти алгоритм, который моделирует
<a href="/log/2018/05/07/quantumly-important.html">один запуск квантового
компьютера</a>. Выдается одно базисное состояние, случайно выбранное из
распределения, соответствующего заданной квантовой цепи и начальному состоянию.
</p>

<p>
Пусть нам дано <math><mi> t </mi></math> унитарных преобразований
<math><msub><mi> U </mi><mn> 1 </mn></msub></math>,
<math><msub><mi> U </mi><mn> 2 </mn></msub></math>, ...,
<math><msub><mi> U </mi><mi> t </mi></msub></math>
и начальное состояние <math><mi> t </mi></math> кубитов в виде вектора
<math><msub><mi> &psi; </mi><mn> 0 </mn></msub></math> размерности
<math><msup><mn> 2 </mn><mi> n </mi></msup></math>.
Тогда определим состояние кубитов после применения <math><msub><mi> U </mi><mi> i </mi></msub></math> рекуррентно:

<math display="block">
  <mrow>
    <msub><mi> &psi; </mi><mi> i </mi></msub>
    <mo> = </mo>
    <mrow>
      <msub><mi> U </mi><mi> i </mi></msub>
      <msub><mi> &psi; </mi><mrow> <mi>i</mi> <mo>&minus;</mo> <mn>1</mn> </mrow></msub>
    </mrow>
  </mrow>
</math>
</p>

<p>
Первый способ промоделировать поведение квантового компьютера заключается в
том, чтобы использовать генератор псевдослучайных чисел по распределению
<math>
  <mrow>
    <msub><mi> &psi; </mi><mi> t </mi></msub>
    <mo>&CircleDot;</mo>
    <msubsup>
      <mi> &psi; </mi>
      <mi> t </mi>
      <mo>*</mo>
    </msup>
  </mrow>
</math>
(покомпонентное произведение вектора с его комплексным
сопряжением). Недостаток способа в том, что вектор
<math><msub><mi> &psi; </mi><mi> t </mi></msub></math> имеет
<math><msup><mn> 2 </mn><mi> n </mi></msup></math>
компонентов: для <math><mrow><mi> n </mi><mo> = </mo><mn> 40 </mn></mrow></math>
получится
<math><msup><mn> 10 </mn><mn> 12 </mn></msup></math>
чисел, которые вряд ли влезут в
оперативную память вашего компьютера.
</p>

<p>
К счастью, существует теорема $\mathtt{BQP} \subseteq \mathtt{PSPACE}$. Ее
доказательство заключается в том, чтобы вычислять одну компоненту вектора
$\psi_{t,k}$ рекурсивно и без сохранения промежуточных результатов.

$$\psi_{t,k} = \sum_{i=0}^{2^n - 1} U_{t,k,i} \cdot \psi_{t-1,i}$$

В реальности большинство из слагаемых этой суммы равны нулю. Например, для
Тоффоли, $\mathtt{cNOT}$ и других «классических» вентилей количество ненулевых
слагаемых равно одному, а для вентиля Адамара — двум.
Таким образом, каждый компонент $\psi_t$ вычисляется за $\Oh{2^t}$.
</p>

<p>
Такой подход экономит память, но требует перебирать много конечных состояний:
в квантовой механике трудно предсказать, какие из них будут иметь вероятности
около нуля.
</p>

<p>
Майкл Франк в 2009 году воспользовался идеей Дэвида Бома: квантовая система
находится в одном определенном базисном состоянии в каждый момент времени.
Если очередное преобразование относится к классическим вентилям, то просто
выполняется детерминированный переход. Если же это, к примеру, вентиль
Адамара, то делается случайный выбор из двух возможных состояний $k_1$ и
$k_2$. Первое состояние будет выбрано с такой вероятностью:

$$p_{i,k_1} = \frac{|\psi_{i,k_1}|^2}{|\psi_{i,k_1}|^2 + |\psi_{i,k_2}|^2}$$
</p>

<p>
Алгоритм выполняет всю квантовую цепь за $\Oh{2^t}$, так как верно следующее
равенство:

$$\sum_{i=0}^{t-1}{2^i}=2^t - 1$$
</p>

<p>
Алгоритм выдает конечные состояния в соответствии с распределением
$\psi_t \circ \psi_t^*$. Это доказывается по индукции: предположим, что на
шаге $t-1$ любое состояние $k_i$ выбирается с корректной вероятностью
$|\psi_{t-1,k_i}|^2$. Тогда:

<ol>
<li>
Если $U_t$ — «классический вентиль», то новое состояние будет выбранно также с
корректной вероятностью. Это следует из того, что такие преобразования всего
лишь делают перестановку амплитуд.
</li>

<li>
Если $U_t$ — вентиль Адамара, то все состояния делятся на пары
$k_1$ и $k_2$ для преобразования. Заметим, что для любой такой пары верно
равенство:

$$|\psi_{t-1,k_1}|^2 + |\psi_{t-1,k_2}|^2
= |\psi_{t,k_1}|^2 + |\psi_{t,k_2}|^2$$

Тогда $k_1$ будет выбран при переходе либо из $k_1$, либо из $k_2$ с такой
вероятностью:

$$|\psi_{t-1,k_1}|^2 \cdot
  p_{t,k_1}
+ |\psi_{t-1,k_2}|^2 \cdot
  p_{t,k_1}
=
|\psi_{t,k_1}|^2
\cdot
\frac{|\psi_{t-1,k_1}|^2 + |\psi_{t-1,k_2}|^2}
{|\psi_{t,k_1}|^2 + |\psi_{t,k_2}|^2}
=
|\psi_{t,k_1}|^2
$$

</li>
</ol>
</p>

<p>
Напоследок приведем иллюстрацию <a href="https://arxiv.org/abs/0812.3675">
из оригинальной статьи</a>, которая показывает преимущества алгоритма для
целей отладки.
</p>

<img src="quantum-trace.png"/>

</body>
</html>
