<!DOCTYPE html>
<html>
<head>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']]},
  TeX: {
    Macros: {
      Oh: ["\\mathcal{O}(#1)", 1]
    }
  }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<title>
Д. Урбанович — Алгоритм Франка
</title>

</head>
<body>

<h1>
Алгоритм Франка
</h1>

<p>
<a href="/log">Дмитрий Урбанович</a>
</p>

<p>
Ижевск, 15—16 июня 2018
</p>

<hr/>

<p>
Алгоритм Франка — это легкий по затратам памяти алгоритм, который моделирует
<a href="/log/2018/05/07/quantumly-important.html">один запуск квантового
компьютера</a>. Выдается одно базисное состояние, случайно выбранное из
распределения, соответствующего заданной квантовой цепи и начальному состоянию.
</p>

<p>
Пусть нам дано $t$ унитарных преобразований $U_1, U_2, \ldots, U_t$
и начальное состояние $n$ кубитов в виде вектора $\psi_0$ размерности $2^n$.
Тогда определим состояние кубитов после применения $U_i$ рекуррентно:
$$\psi_i = U_i \cdot \psi_{i-1}$$
</p>

<p>
Первый способ промоделировать поведение квантового компьютера заключается в
том, чтобы использовать генератор псевдослучайных чисел по распределению
$\psi_t \circ \psi_t^*$ (покомпонентное произведение вектора с его комплексным
сопряжением). Недостаток способа в том, что вектор $\psi_t$ имеет $2^n$
компонентов: для $n=40$ получится $10^{12}$ чисел, которые вряд ли влезут в
оперативную память вашего компьютера.
</p>

<p>
К счастью, существует теорема $\mathtt{BQP} \subseteq \mathtt{PSPACE}$. Ее
доказательство заключается в том, чтобы вычислять одну компоненту вектора
$\psi_{t,k}$ рекурсивно и без сохранения промежуточных результатов.

$$\psi_{t,k} = \sum_{i=0}^{2^n} U_{t,k,i} \cdot \psi_{t-1,i}$$

В реальности большинство из слагаемых этой суммы равны нулю. Например, для
Тоффоли, $\mathtt{cNOT}$ и других «классических» вентилей количество ненулевых
слагаемых равно одному, а для вентиля Адамара — двум.
Таким образом, каждый компонент $\psi_t$ вычисляется за $\Oh{2^t}$.
</p>

<p>
Такой подход экономит память, но требует перебирать много конечных состояний:
в квантовой механике трудно предсказать, какие из них будут иметь вероятности
около нуля.
</p>

<p>
Майкл Франк в 2009 году воспользовался идеей Дэвида Бома: квантовая система
находится в одном определенном базисном состоянии в каждый момент времени.
Если очередное преобразование относится к классическим вентилям, то просто
выполняется детерминированный переход. Если же это, к примеру, вентиль
Адамара, то делается случайный выбор из двух возможных состояний $k_1$ и
$k_2$. Первое состояние будет выбрано с такой вероятностью:

$$\frac{|\psi_{i,k_1}|^2}{|\psi_{i,k_1}|^2 + |\psi_{i,k_2}|^2}$$
</p>

<p>
Алгоритм выполняет всю квантовую цепь за $\Oh{2^t}$, так как верно следующее
равенство:

$$\sum_{i=0}^{t-1}{2^i}=2^t - 1$$
</p>

<p>
Алгоритм выдает конечные состояния в соответствии с распределением
$\psi_t \circ \psi_t^*$. Это доказывается по индукции: предположим, что на
шаге $t-1$ любое состояние $k_i$ выбирается с корректной вероятностью
$|\psi_{t-1,k_i}|^2$. Тогда:

<ol>
<li>
Если $U_t$ — «классический вентиль», то новое состояние будет выбранно также с
корректной вероятностью. Это следует из того, что такие преобразования всего
лишь делают перестановку амплитуд.
</li>

<li>
Если $U_t$ — вентиль Адамара, то все состояния делятся на две категории:
те, что без изменений (см. предыдущий пункт), и те, что входят в пару
$k_1$ и $k_2$ для преобразования. Заметим, что для любой такой пары верно
равенство:

$$|\psi_{t-1,k_1}|^2 + |\psi_{t-1,k_2}|^2
= |\psi_{t,k_1}|^2 + |\psi_{t,k_2}|^2$$

Тогда $k_1$ будет выбран при переходе либо из $k_1$, либо из $k_2$ с такой
вероятностью:

$$|\psi_{t-1,k_1}|^2 \cdot
  \frac{|\psi_{t,k_1}|^2}{|\psi_{t,k_1}|^2 + |\psi_{t,k_2}|^2}
+ |\psi_{t-1,k_2}|^2 \cdot
  \frac{|\psi_{t,k_1}|^2}{|\psi_{t,k_1}|^2 + |\psi_{t,k_2}|^2}
=
\frac{(|\psi_{t-1,k_1}|^2 + |\psi_{t-1,k_2}|^2) |\psi_{t,k_1}|^2}
{|\psi_{t,k_1}|^2 + |\psi_{t,k_2}|^2}
=
|\psi_{t,k_1}|^2
$$

</li>
</ol>
</p>

<p>
Напоследок приведем иллюстрацию <a href="https://arxiv.org/abs/0812.3675">
из оригинальной статьи</a>, которая показывает преимущества алгоритма для
целей отладки.
</p>

<img src="quantum-trace.png"/>

</body>
</html>
